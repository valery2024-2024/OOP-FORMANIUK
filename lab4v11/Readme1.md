# Контрольні відповіді до лабораторної роботи №4
---
## 1) У чому різниця між абстрактним класом і інтерфейсом?
* **Абстрактний клас** - це напівготовий базовий клас, який може містити як абстрактні методи (без реалізації), так і вже готові методи. Він зручний для ситуацій, коли кілька похідних класів повинні мати спільну поведінку або поля. > `ProductBase` — це абстрактний клас, який  містить спільні властивості (`Name`,  `UnitPrice`, `Quantity`) і реалізацію методу `TotalPrice()`.
* **Інтерфейс** - це чистий контракт, який лише описує, що повинно бути реалізовано, але не містить готової логіки. `IProduct` — це інтерфейс, який визначає обов’язкові методи й властивості для всіх товарів.

## 2) Коли краще використовувати композицію, а коли наслідування?
* **Наслідування** - доцільне, коли між класами існує відношення «є» (is-a). `Food` і `Clothes` є різновидами базового класу `ProductBase`.
* **Композиція** - краще, коли об’єкт складається з інших об’єктів (has-a).
`Cart` має список товарів (`List<IProduct>`). Це дозволяє кошику містити будь-які продукти, незалежно від того, чи це їжа, чи одяг.

## 3) Як працює агрегація та чим вона відрізняється від композиції?
* **Агрегація** - це слабкий зв’язок.Головний клас посилається на інші об’єкти, але не володіє ними. Тобто вони можуть існувати й без нього. Клас `Order` агрегує `Customer` і `Cart`. Якщо видалити `Order`, то об’єкт `Customer` (замовник) продовжить існувати самостійно.
* **Композиція** - означає сильний зв’язок. Життєвий цикл частин залежить від цілого. Якщо знищити `Cart`, то й товари, що зберігаються в його списку, зникнуть.

## 4) Чи може клас реалізовувати кілька інтерфейсів одночасно?
* **У `C#`** клас може реалізувати скільки завгодно інтерфейсів. Це дозволяє поєднувати різні контракти в одному класі. Це особливо важливо в ООП, бо в `C#` немає множинного наслідування класів, але є можливість реалізації багатьох інтерфейсів.

## 5) Для чого в ООП використовують інтерфейси як контракти?
* **Контракт** гарантує, що будь-який клас, який реалізує інтерфейс, матиме потрібні методи й властивості. Це дозволяє будувати гнучкі системи, де різні класи можна підміняти один одним, якщо вони реалізують один і той самий інтерфейс. Метод `Cart` працює із колекцією `List<IProduct>`. Йому байдуже, чи в кошику `Food`, чи `Clothes`, бо всі вони реалізують один контракт `IProduct`.